<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>CR Inverse Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js" onerror="window.chartJsLoadFailed=true;"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" onerror="window.katexLoadFailed=true;">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" onerror="window.katexLoadFailed=true;"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" onerror="window.katexLoadFailed=true;"></script>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      :root {
        --bg: #f1f5f9;
        --card: #ffffff;
        --header-bg: #0f172a;
        --text: #1e293b;
        --muted: #94a3b8;
        --border: #e2e8f0;
        --accent: #6366f1;
        --good: #22c55e;
        --shadow: 0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);
        --shadow-md: 0 4px 6px rgba(0,0,0,0.07), 0 2px 4px rgba(0,0,0,0.06);
        --radius: 10px;
        --panel-aspect: 2 / 1;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
        padding: 16px;
        min-height: 100vh;
      }
      .header {
        background: var(--header-bg);
        color: white;
        padding: 14px 20px;
        border-radius: var(--radius);
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
      }
      .header-title { font-size: 18px; font-weight: 800; letter-spacing: -0.3px; }
      .header-sub { font-size: 12px; color: var(--muted); margin-top: 2px; }
      .status {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: var(--muted);
        background: #1e293b;
        padding: 6px 10px;
        border-radius: 999px;
      }
      .dot { width: 8px; height: 8px; border-radius: 50%; background: #ef4444; }
      .dot.on { background: var(--good); box-shadow: 0 0 6px var(--good); }

      .grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        align-items: start;
      }
      .row2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        align-items: start;
      }
      @media (max-width: 960px) {
        .row2 { grid-template-columns: 1fr; }
      }
      .card {
        background: var(--card);
        border-radius: var(--radius);
        box-shadow: var(--shadow-md);
        border: 1px solid var(--border);
        padding: 14px 16px;
      }
      .controls {
        display: grid;
        grid-template-columns: 1.2fr 1fr 1fr 1fr 1fr 1fr 1fr auto;
        gap: 10px;
        align-items: end;
        margin-top: 10px;
      }
      @media (max-width: 1100px) {
        .controls { grid-template-columns: 1fr 1fr 1fr; }
      }
      .field label {
        display: block;
        font-size: 11px;
        color: #64748b;
        font-weight: 700;
        margin-bottom: 4px;
      }
      .field input, .field select {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 8px 10px;
        background: #f8fafc;
        color: #0f172a;
        font-size: 12px;
        outline: none;
      }
      .field input:focus, .field select:focus {
        border-color: rgba(99,102,241,0.55);
        box-shadow: 0 0 0 3px rgba(99,102,241,0.15);
      }
      .toggleRow {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 8px 10px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: #f8fafc;
        height: 38px;
      }
      .toggleRow .kpi { margin: 0; }
      .btn {
        appearance: none;
        border: 0;
        border-radius: 12px;
        padding: 10px 14px;
        background: linear-gradient(180deg, #111827, #0b1220);
        color: #fff;
        font-weight: 800;
        font-size: 12px;
        cursor: pointer;
        height: 38px;
        box-shadow: var(--shadow);
      }
      .btn:active { transform: translateY(1px); }
      .runStatus {
        margin-top: 8px;
        font-size: 12px;
        color: #64748b;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .panel {
        display: flex;
        flex-direction: column;
        min-width: 0;
      }
      .row { display: flex; justify-content: space-between; align-items: center; gap: 10px; flex-wrap: wrap; }
      .kpi { font-size: 12px; color: #64748b; }
      .kpi b { color: var(--text); }
      .bar {
        width: 100%; height: 6px; border-radius: 999px;
        background: #e5e7eb; overflow: hidden; margin-top: 8px;
      }
      .bar > div {
        height: 100%; width: 0%;
        background: linear-gradient(90deg, #60a5fa, #34d399);
        transition: width 0.2s ease;
      }
      .segmented {
        display: inline-flex;
        border: 1px solid var(--border);
        border-radius: 10px;
        overflow: hidden;
        background: #f8fafc;
      }
      .seg-btn {
        appearance: none;
        border: 0;
        background: transparent;
        color: #475569;
        padding: 6px 10px;
        font-size: 11px;
        font-weight: 700;
        cursor: pointer;
        border-right: 1px solid var(--border);
      }
      .seg-btn:last-child { border-right: 0; }
      .seg-btn.active { background: #0f172a; color: white; }
      /* Keep optima + spectrum chart areas the same height. */
      .chartBox {
        position: relative;
        width: 100%;
        height: 360px;
        margin-top: 10px;
      }
      .chartBox canvas { width: 100% !important; height: 100% !important; }

      .thumbs { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 10px; }
      @media (max-width: 960px) { .thumbs { grid-template-columns: repeat(3, 1fr); } }
      @media (max-width: 600px) { .thumbs { grid-template-columns: repeat(2, 1fr); } }
      .thumb {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 8px;
        background: #f8fafc;
        cursor: pointer;
      }
      .thumb.sel { outline: 2px solid var(--accent); }
      .thumb img { width: 100%; border-radius: 8px; image-rendering: pixelated; display: block; }
      .cap { font-size: 11px; color: #64748b; margin-top: 6px; }
      .hint { font-size: 11px; color: #64748b; margin-top: 6px; }
      .formulaBox {
        margin-top: 10px;
        background: #f8fafc;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 12px;
        color: #0f172a;
        overflow: auto;
        max-height: 420px;
      }
      .formulaLatex {
        font-size: 13px;
        line-height: 1.85;
        white-space: pre-wrap;
      }
      .katex { font-size: 1.0em; }
    </style>
  </head>
  <body>
    <div class="header">
      <div>
        <div class="header-title">CR Inverse Dashboard</div>
        <div class="header-sub">Optimization loss, progress, Top-K, and spectrum</div>
      </div>
      <div class="status"><span id="dot" class="dot"></span><span id="statusText">disconnected</span></div>
    </div>

    <div class="grid">
      <!-- Run controls -->
      <div class="card panel">
        <div class="row">
          <div class="kpi"><b>Run</b> start optimization from dashboard</div>
          <div class="toggleRow">
            <div class="kpi"><b>FDTD verify</b></div>
            <input id="fdtdToggle" type="checkbox" />
          </div>
        </div>
        <div class="controls">
          <div class="field">
            <label for="inDevice">device</label>
            <select id="inDevice">
              <option value="cpu">cpu</option>
              <option value="cuda">cuda</option>
            </select>
          </div>
          <div class="field">
            <label for="inNStart">n_start</label>
            <input id="inNStart" type="number" min="1" step="1" value="1000" />
          </div>
          <div class="field">
            <label for="inNSteps">n_steps</label>
            <input id="inNSteps" type="number" min="1" step="1" value="1000" />
          </div>
          <div class="field">
            <label for="inTopk">topk</label>
            <input id="inTopk" type="number" min="1" step="1" value="10" />
          </div>
          <div class="field">
            <label for="inRobust">robustness_samples</label>
            <input id="inRobust" type="number" min="1" step="1" value="2" />
          </div>
          <div class="field">
            <label for="inChunk">chunk_size</label>
            <input id="inChunk" type="number" min="1" step="1" value="64" />
          </div>
          <div class="field">
            <label for="inFdtdEvery">fdtd_every</label>
            <input id="inFdtdEvery" type="number" min="0" step="1" value="10" />
          </div>
          <button class="btn" id="runBtn">Run optimization</button>
        </div>
        <div class="runStatus" id="runStatus"></div>
      </div>

      <!-- Top row: optima (left) + spectrum (right), same size -->
      <div class="row2">
        <div class="card panel">
        <div class="row">
          <div class="kpi"><b>Optimization</b> <span id="kpiStep">-</span></div>
          <div class="row" style="gap:8px">
            <div class="kpi">Y</div>
            <div class="segmented" id="scaleToggle">
              <button class="seg-btn" data-scale="log">Log</button>
              <button class="seg-btn" data-scale="linear">Linear</button>
            </div>
            <div class="kpi">Window</div>
            <div class="segmented" id="windowToggle">
              <button class="seg-btn" data-window="all">All</button>
              <button class="seg-btn" data-window="200">200</button>
              <button class="seg-btn" data-window="50">50</button>
            </div>
          </div>
        </div>
        <div class="bar"><div id="progFill"></div></div>
        <div class="row" style="margin-top:8px">
          <div class="kpi">loss_total: <b id="kpiLoss">-</b></div>
        </div>
        <div class="chartBox"><canvas id="lossChart"></canvas></div>
        </div>

        <div class="card panel">
        <div class="row">
          <div class="kpi"><b>Spectrum</b> <span id="kpiSpec">-</span></div>
          <div class="kpi" id="specHint">click a thumbnail</div>
        </div>
        <div class="chartBox"><canvas id="specChart"></canvas></div>
      </div>
      </div>

      <!-- Bottom row: Top-K (left) + Loss formula (right) -->
      <div class="row2">
        <div class="card panel">
          <div class="row">
            <div class="kpi"><b>Top-K</b> <span id="kpiTopk">-</span></div>
            <div class="kpi" id="topkHint"></div>
          </div>
          <div class="thumbs" id="thumbs"></div>
          <div class="hint">Tip: click a thumbnail to update spectrum.</div>
        </div>

        <div class="card panel">
          <div class="row">
            <div class="kpi"><b>Loss Definition</b></div>
            <div class="kpi">robust MC: E_{sigma,tau}[L] (Monte Carlo average)</div>
          </div>
          <div class="formulaBox">
            <div class="formulaLatex" id="lossFormula"></div>
            <pre id="lossFormulaTex" style="display:none">\begin{aligned}
&\textbf{Purity matrix (30ch bins):}\\
&\qquad I_B=\{0,\dots,9\},\quad I_G=\{10,\dots,19\},\quad I_R=\{20,\dots,29\}.\\
&\qquad A_{c,b}=\frac{1}{|I_b|}\sum_{k\in I_b} s_{c,k},\qquad A\in\mathbb{R}^{3\times 3}.\\[10pt]
&\textbf{Spectral loss:}\\
&\qquad L_{\mathrm{purity}}=\lVert A-I\rVert_F^2,\qquad
L_{\mathrm{abs}}=\lVert \mathbf{1}-\mathrm{diag}(A)\rVert_2^2.\\
&\qquad L_{\mathrm{spec}}=
w_{\mathrm{purity}}L_{\mathrm{purity}}+w_{\mathrm{abs}}L_{\mathrm{abs}}.\\[10pt]
&\textbf{Regularization:}\\
&\qquad L_{\mathrm{gray}}=\mathrm{mean}\big(u(1-u)\big),\qquad
L_{\mathrm{tv}}=\mathrm{TV}(u).\\
&\qquad L_{\mathrm{reg}}=w_{\mathrm{gray}}L_{\mathrm{gray}}+w_{\mathrm{tv}}L_{\mathrm{tv}}.\\[10pt]
&\textbf{Total (robust MC):}\\
&\qquad L_{\mathrm{total}}=\mathbb{E}_{(\sigma,\tau)}\big[L_{\mathrm{spec}}+L_{\mathrm{reg}}\big]
\ \approx\ \frac{1}{N}\sum_{n=1}^{N}\big(L_{\mathrm{spec}}^{(n)}+L_{\mathrm{reg}}^{(n)}\big).
\end{aligned}</pre>
          </div>
        </div>
      </div>

    <script>
      const dot = document.getElementById('dot');
      const statusText = document.getElementById('statusText');
      const kpiStep = document.getElementById('kpiStep');
      const kpiLoss = document.getElementById('kpiLoss');
      const progFill = document.getElementById('progFill');
      const kpiTopk = document.getElementById('kpiTopk');
      const thumbs = document.getElementById('thumbs');
      const topkHint = document.getElementById('topkHint');
      const kpiSpec = document.getElementById('kpiSpec');
      const specHint = document.getElementById('specHint');

      function setStatus(ok, text){
        dot.classList.toggle('on', ok);
        statusText.textContent = text;
      }
      async function fetchJSON(url){
        const r = await fetch(url, {cache:'no-store'});
        if (!r.ok) throw new Error(String(r.status));
        return await r.json();
      }

      const ui = {
        scale: localStorage.getItem('loss_scale') || 'log',
        window: localStorage.getItem('loss_window') || 'all',
        fdtd: (localStorage.getItem('fdtd_verify') || 'off'),
        selected: {step:null, idx:0},
        lastTopkKey: ''
      };

      function initSegmented(el, key, values){
        const buttons = Array.from(el.querySelectorAll('.seg-btn'));
        function sync(){
          buttons.forEach(b => b.classList.toggle('active', b.dataset[key] === ui[key]));
        }
        buttons.forEach(b => {
          b.addEventListener('click', () => {
            ui[key] = b.dataset[key];
            localStorage.setItem('loss_' + key, ui[key]);
            sync();
            redraw();
          });
        });
        // default
        if (!values.includes(ui[key])) ui[key] = values[0];
        sync();
      }

      let lossChart = null;
      let specChart = null;

      function setRunStatus(text){
        const el = document.getElementById('runStatus');
        if (el) el.textContent = text || '';
      }

      function makeLossChart(){
        const ctx = document.getElementById('lossChart');
        const gridColor = '#e2e8f0';
        const tickColor = '#94a3b8';
        const fontFamily = '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif';
        lossChart = new Chart(ctx, {
          type: 'line',
          data: { labels: [], datasets: [
            {
              label: 'loss_total',
              data: [],
              borderColor: '#3b82f6',
              backgroundColor: 'rgba(59,130,246,0.08)',
              fill: true,
              borderWidth: 2,
              tension: 0.4,
              pointRadius: 0,
              pointHoverRadius: 4
            },
          ]},
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            interaction: { mode: 'index', intersect: false },
            scales: {
              y: {
                type: 'logarithmic',
                grid: { color: gridColor },
                ticks: { color: tickColor, font: { size: 11, family: fontFamily } },
                title: {
                  display: true,
                  text: (ui.scale === 'linear') ? 'Loss' : 'Loss (log)',
                  color: tickColor,
                  font: { size: 12, family: fontFamily }
                }
              },
              x: {
                grid: { color: gridColor, display: false },
                ticks: { color: tickColor, font: { size: 11, family: fontFamily }, maxTicksLimit: 20 },
                title: { display: true, text: 'step', color: tickColor, font: { size: 12, family: fontFamily } }
              }
            },
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: { usePointStyle: true, pointStyle: 'line', font: { size: 12, family: fontFamily } }
              },
              tooltip: {
                backgroundColor: '#0f172a',
                titleFont: { size: 12, family: fontFamily },
                bodyFont: { size: 11, family: fontFamily },
                callbacks: {
                  label: (ctx) => {
                    const name = (ctx && ctx.dataset && ctx.dataset.label) ? String(ctx.dataset.label) : 'loss';
                    const v = (ctx && ctx.parsed) ? ctx.parsed.y : null;
                    if (v == null || !Number.isFinite(v)) return `${name}: --`;
                    const s = (v >= 0.01) ? v.toFixed(6) : v.toExponential(3);
                    return `${name}: ${s}`;
                  },
                }
              }
            }
          }
        });
      }

      function makeSpecChart(){
        const ctx = document.getElementById('specChart');
        const gridColor = '#e2e8f0';
        const tickColor = '#94a3b8';
        const fontFamily = '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif';
        specChart = new Chart(ctx, {
          type: 'line',
          data: { labels: [], datasets: [
            // Predicted (forward model): dashed + lighter.
            { label: 'R pred', data: [], borderColor: 'rgba(239,68,68,0.35)', borderWidth: 2, borderDash: [6,4], pointRadius: 0, tension: 0.4 },
            { label: 'G pred', data: [], borderColor: 'rgba(34,197,94,0.35)', borderWidth: 2, borderDash: [6,4], pointRadius: 0, tension: 0.4 },
            { label: 'B pred', data: [], borderColor: 'rgba(59,130,246,0.35)', borderWidth: 2, borderDash: [6,4], pointRadius: 0, tension: 0.4 },
            // FDTD verified: solid.
            { label: 'R fdtd', data: [], borderColor: '#ef4444', borderWidth: 2, pointRadius: 0, tension: 0.4, hidden: true },
            { label: 'G fdtd', data: [], borderColor: '#22c55e', borderWidth: 2, pointRadius: 0, tension: 0.4, hidden: true },
            { label: 'B fdtd', data: [], borderColor: '#3b82f6', borderWidth: 2, pointRadius: 0, tension: 0.4, hidden: true },
          ]},
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            interaction: { mode: 'index', intersect: false },
            scales: {
              x: {
                grid: { display: false },
                ticks: { color: tickColor, font: { size: 10, family: fontFamily }, maxTicksLimit: 20 },
                title: { display: true, text: 'wavelength (nm)', color: tickColor, font: { size: 11, family: fontFamily } }
              },
              y: {
                grid: { color: gridColor },
                ticks: { color: tickColor, font: { size: 10, family: fontFamily } },
                title: { display: true, text: 'intensity', color: tickColor, font: { size: 11, family: fontFamily } }
              }
            },
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: { usePointStyle: true, pointStyle: 'line', font: { size: 11, family: fontFamily }, boxWidth: 20 }
              },
              tooltip: {
                backgroundColor: '#0f172a',
                titleFont: { size: 12, family: fontFamily },
                bodyFont: { size: 11, family: fontFamily }
              }
            }
          }
        });
      }

      function updateLossScale(){
        if (!lossChart) return;
        lossChart.options.scales.y.type = (ui.scale === 'log') ? 'logarithmic' : 'linear';
        if (lossChart.options.scales.y.title) {
          lossChart.options.scales.y.title.text = (ui.scale === 'linear') ? 'Loss' : 'Loss (log)';
        }
      }

      let lastStatus = null;

      async function redraw(){
        // use cached status to update chart options quickly
        if (lastStatus) {
          applyStatus(lastStatus);
        }
      }

      function applyStatus(st){
        const meta = st.meta || {};
        const series = st.series || {};
        const steps = series.steps || [];
        const total = Number(meta.n_steps);

        const latest = st.latest || {};
        const curStep = Number(latest.step);
        if (Number.isFinite(curStep)) {
          kpiStep.textContent = (Number.isFinite(total) && total>0) ? `(step ${curStep} / ${total-1})` : `(step ${curStep})`;
          if (Number.isFinite(total) && total>0) {
            const pct = Math.max(0, Math.min(1, curStep / Math.max(1, total-1))) * 100;
            progFill.style.width = pct.toFixed(1) + '%';
          }
        }
        const lt = Number(latest.loss_total);
        kpiLoss.textContent = Number.isFinite(lt) ? lt.toFixed(6) : '-';

        // windowing
        let windowN = ui.window === 'all' ? null : Number(ui.window);
        let startIdx = 0;
        if (windowN && steps.length > windowN) startIdx = steps.length - windowN;

        const x = steps.slice(startIdx);
        const yTotal = (series.loss_total || []).slice(startIdx);

        updateLossScale();
        lossChart.data.labels = x.map(String);
        lossChart.data.datasets[0].data = yTotal;
        lossChart.update();
      }

      async function tick(){
        try{
          await fetchJSON('/api/ping');
          setStatus(true, 'live');
        } catch(e) {
          setStatus(false, 'disconnected');
          return;
        }

        try{
          const st = await fetchJSON('/api/status?window=all');
          lastStatus = st;
          applyStatus(st);
        } catch(e) { /* ignore */ }

        // Run status
        try{
          const rs = await fetchJSON('/api/run/status');
          if (rs.running) {
            const tail = rs.tail || [];
            setRunStatus('running: ' + (tail.length ? tail[tail.length-1] : '...'));
          } else if (rs.last_exit_code != null) {
            setRunStatus('last exit: ' + rs.last_exit_code);
          }
        } catch(e) { /* ignore */ }

        // TopK
        try{
          const t = await fetchJSON('/api/topk/latest');
          if (t.step == null) {
            kpiTopk.textContent = '(no snapshot)';
            thumbs.innerHTML = '';
            topkHint.textContent = '';
            return;
          }
          const key = String(t.step) + ':' + String(t.k);
          kpiTopk.textContent = `(step ${t.step}, K=${t.k})`;
          if (key !== ui.lastTopkKey) {
            ui.lastTopkKey = key;
            const imgs = t.images || [];
            const fill = t.fill_frac || [];
            const best = (t.metrics && t.metrics.metric_best_loss) ? t.metrics.metric_best_loss : null;
            let html = '';
            const maxShow = Math.min(imgs.length, 8);
            for (let i=0;i<maxShow;i++){
              const src = imgs[i] + '?v=' + encodeURIComponent(String(t.step));
              const cap = [
                best && best[i]!=null ? `best_loss=${Number(best[i]).toFixed(6)}` : null,
                fill && fill[i]!=null ? `fill=${Number(fill[i]).toFixed(3)}` : null
              ].filter(Boolean).join('  ') || `k=${i}`;
              html += `<div class="thumb" data-step="${t.step}" data-idx="${i}"><img src="${src}" /><div class="cap">${cap}</div></div>`;
            }
            thumbs.innerHTML = html;
            topkHint.textContent = 'click a thumb to plot spectrum';

            // auto-select k=0
            ui.selected.step = t.step;
            ui.selected.idx = 0;
            await loadSpectrum(t.step, 0);
          }
        } catch(e) { /* ignore */ }
      }

      async function loadSpectrum(step, idx){
        kpiSpec.textContent = `(step ${step}, k=${idx})`;
        try{
          const s = await fetchJSON(`/api/topk/${step}/${idx}/spectrum`);
          const rgb = s.rgb || null;
          if (!rgb) throw new Error('no rgb');
          const C = rgb[0].length;
          // Default wavelength grid: 400..700 nm, evenly spaced over C channels.
          const wl = Array.from({length: C}, (_,i) => 400 + (300 * i) / Math.max(1, (C - 1)));
          specChart.data.labels = wl.map(v => v.toFixed(0));
          specChart.data.datasets[0].data = rgb[0];
          specChart.data.datasets[1].data = rgb[1];
          specChart.data.datasets[2].data = rgb[2];
          // Hide FDTD datasets by default; show only if loaded.
          specChart.data.datasets[3].hidden = true;
          specChart.data.datasets[4].hidden = true;
          specChart.data.datasets[5].hidden = true;

          if (ui.fdtd === 'on') {
            try{
              const f = await fetchJSON(`/api/topk/${step}/${idx}/fdtd_spectrum`);
              if (f && f.rgb) {
                const frgb = f.rgb;
                specChart.data.datasets[3].data = frgb[0];
                specChart.data.datasets[4].data = frgb[1];
                specChart.data.datasets[5].data = frgb[2];
                specChart.data.datasets[3].hidden = false;
                specChart.data.datasets[4].hidden = false;
                specChart.data.datasets[5].hidden = false;
                specHint.textContent = `pred vs FDTD: 3x${C} (400-700 nm)`;
              }
            } catch(e) {
              // no fdtd available
            }
          }
          specChart.update();
          if (specHint.textContent === 'click a thumbnail' || specHint.textContent === '') {
            specHint.textContent = `forward model output: 3x${C} (400-700 nm)`;
          }
        } catch(e) {
          specHint.textContent = 'spectrum unavailable (surrogate not configured)';
        }
      }

      thumbs.addEventListener('click', async (ev) => {
        const el = ev.target.closest('.thumb');
        if (!el) return;
        const step = el.getAttribute('data-step');
        const idx = el.getAttribute('data-idx');
        if (step == null || idx == null) return;
        ui.selected.step = Number(step);
        ui.selected.idx = Number(idx);
        Array.from(thumbs.querySelectorAll('.thumb')).forEach(x => x.classList.toggle('sel', x === el));
        await loadSpectrum(step, idx);
      });

      initSegmented(document.getElementById('scaleToggle'), 'scale', ['log','linear']);
      initSegmented(document.getElementById('windowToggle'), 'window', ['all','200','50']);
      makeLossChart();
      makeSpecChart();

      // FDTD verify toggle + run button
      const fdtdToggle = document.getElementById('fdtdToggle');
      if (fdtdToggle) {
        fdtdToggle.checked = (ui.fdtd === 'on');
        fdtdToggle.addEventListener('change', () => {
          ui.fdtd = fdtdToggle.checked ? 'on' : 'off';
          localStorage.setItem('fdtd_verify', ui.fdtd);
          // refresh spectrum overlay if a thumb is selected
          if (ui.selected.step != null) loadSpectrum(ui.selected.step, ui.selected.idx);
        });
      }
      const runBtn = document.getElementById('runBtn');
      if (runBtn) {
        runBtn.addEventListener('click', async () => {
          const nStart = Number(document.getElementById('inNStart')?.value || 200);
          const nSteps = Number(document.getElementById('inNSteps')?.value || 2000);
          const topk = Number(document.getElementById('inTopk')?.value || 50);
          const rs = Number(document.getElementById('inRobust')?.value || 8);
          const dev = String(document.getElementById('inDevice')?.value || 'cpu');
          const chunk = Number(document.getElementById('inChunk')?.value || 64);
          const fdtdEvery = Number(document.getElementById('inFdtdEvery')?.value || 10);
          try{
            const url = `/api/run/start?n_start=${encodeURIComponent(nStart)}&n_steps=${encodeURIComponent(nSteps)}&topk=${encodeURIComponent(topk)}&robustness_samples=${encodeURIComponent(rs)}&device=${encodeURIComponent(dev)}&chunk_size=${encodeURIComponent(chunk)}&fdtd_verify=${ui.fdtd==='on'?1:0}&fdtd_every=${encodeURIComponent(fdtdEvery)}`;
            const r = await fetch(url, {method:'POST'});
            if (!r.ok) throw new Error(String(r.status));
            setRunStatus('started');
          } catch(e) {
            setRunStatus('failed to start');
          }
        });
      }

      function renderLatex(){
        const box = document.getElementById('lossFormula');
        const texEl = document.getElementById('lossFormulaTex');
        if (!box || !texEl) return;
        const tex = (texEl.textContent || '').trim();
        if (!tex) return;
        if (window.katex && window.katex.render) {
          try {
            window.katex.render(tex, box, { displayMode: true, throwOnError: false, strict: "ignore" });
            return;
          } catch(e) {}
        }
        // Fallback: show raw TeX if KaTeX failed to load.
        box.textContent = tex;
      }
      // KaTeX scripts are loaded with `defer`, so render on load (reference style).
      window.addEventListener('load', () => {
        renderLatex();
        // If KaTeX is a little late (slow CDN), retry briefly.
        let tries = 0;
        const timer = setInterval(() => {
          tries += 1;
          if (window.renderMathInElement) renderLatex();
          if (tries >= 6 || window.renderMathInElement) clearInterval(timer);
        }, 250);
      });

      tick();
      setInterval(tick, 1200);
    </script>
  </body>
</html>
